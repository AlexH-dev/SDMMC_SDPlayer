# **Alternative Method: Using a Dedicated Hardware Timer for 44.1kHz Timing (Recommended)**

This approach keeps **HAL's default SysTick (1kHz)** for system timing while using a **separate hardware timer (TIM6/TIM7) for precise 44.1kHz delays**. This ensures compatibility with HAL functions like `HAL_Delay()` while achieving accurate audio-rate timing.

---

## **Step 1: CubeMX Configuration**
### **1. Configure a Basic Timer (TIM6 or TIM7)**
- Go to **"Timers"** â†’ Select **TIM6** or **TIM7** (basic timers, simple to configure).
- Set the following parameters:
  - **Prescaler**: `(SystemCoreClock / 44100) - 1`  
    (Example: For 72MHz, `(72,000,000 / 44,100) - 1 â‰ˆ 1631`)
  - **Counter Mode**: `Up`
  - **Counter Period (AutoReload Register)**: `1` (single count)
  - **Enable Interrupt**: Check **"NVIC Settings"** â†’ Enable **TIM6 global interrupt**.

### **2. Keep SysTick as Default (1kHz)**
- **Do not modify SysTick settings** in CubeMX.
- HAL will continue using 1ms timing for `HAL_Delay()`.

### **3. Generate Code**
- Click **"Generate Code"** to apply changes.

---

## **Step 2: Required Code Implementation**
### **1. Declare Variables & Functions (in `main.h` or a custom header)**
```c
/* USER CODE BEGIN Includes */
#include <stdint.h>
/* USER CODE END Includes */

/* USER CODE BEGIN Private defines */
#define AUDIO_SAMPLE_RATE 44100  // 44.1kHz
extern volatile uint32_t audioTickCounter;  // Tracks 44.1kHz ticks
/* USER CODE END Private defines */

/* USER CODE BEGIN Prototypes */
void Audio_Delay(uint32_t samples);  // Delays in 1/44100s units
/* USER CODE END Prototypes */
```

### **2. Initialize Timer & Define Interrupt Handler (in `main.c`)**
```c
/* USER CODE BEGIN PV */
volatile uint32_t audioTickCounter = 0;  // Counts 44.1kHz ticks
/* USER CODE END PV */

/* USER CODE BEGIN 0 */
// TIM6 Interrupt Handler (called at 44.1kHz)
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM6) {
        audioTickCounter++;  // Increment at 44.1kHz
    }
}
/* USER CODE END 0 */

/* Inside main() */
int main(void) {
    HAL_Init();
    SystemClock_Config();
    MX_TIM6_Init();  // Generated by CubeMX

    // Start TIM6 in interrupt mode
    HAL_TIM_Base_Start_IT(&htim6);

    while (1) {
        // Example: Delay for 1 audio sample (22.676Î¼s)
        Audio_Delay(1);

        // Example: Delay for 1ms (â‰ˆ44.1 samples)
        Audio_Delay(44);  // 44 samples â‰ˆ 0.9977ms
        Audio_Delay(1);   // +1 sample â‰ˆ 1.0204ms (small error)

        // Example: Delay for 100ms (4410 samples)
        Audio_Delay(4410);
    }
}
```

### **3. Implement `Audio_Delay()` (in `main.c` or a separate file)**
```c
/**
 * @brief Busy-wait delay in 44.1kHz sample units (1 unit = 22.676Î¼s)
 * @param samples Number of audio samples to wait
 */
void Audio_Delay(uint32_t samples) {
    uint32_t start = audioTickCounter;
    while ((audioTickCounter - start) < samples) {
        __NOP();  // Minimal power consumption while waiting
    }
}
```

---

## **Step 3: Fine-Tuning for Precision**
### **1. Handling Rounding Errors**
- Since `44,100Hz` doesnâ€™t divide perfectly into common clock speeds (e.g., 72MHz, 168MHz), there will be small timing errors.
- **Solution**: Use a timer with a **higher frequency** and count down:
  ```c
  // Example: For 72MHz, use TIM6 at 1MHz (1Î¼s resolution)
  // CubeMX: Prescaler = 71 (72MHz / 72 = 1MHz)
  // AutoReload = 22.676 (rounded to 23)
  // Then adjust delay logic accordingly.
  ```

### **2. Using DWT Cycle Counter for Sub-Microsecond Precision (Optional)**
- If you need **nanosecond-level precision**, enable the **DWT (Data Watchpoint and Trace)** unit:
  ```c
  void DWT_Init() {
      CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
      DWT->CYCCNT = 0;
      DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
  }

  void Delay_US(uint32_t us) {
      uint32_t start = DWT->CYCCNT;
      uint32_t cycles = us * (SystemCoreClock / 1000000);
      while ((DWT->CYCCNT - start) < cycles);
  }
  ```

---

## **Summary of Changes**
| **Change** | **Location** | **Purpose** |
|------------|-------------|-------------|
| Configure TIM6/TIM7 | CubeMX | Generate 44.1kHz interrupts |
| Declare `audioTickCounter` | `main.h` / `main.c` | Track 44.1kHz ticks |
| Implement `HAL_TIM_PeriodElapsedCallback()` | `main.c` | Increment counter in ISR |
| Write `Audio_Delay()` | `main.c` | Busy-wait delay in 44.1kHz units |
| Start TIM6 interrupt | `main()` | Enable 44.1kHz timing |

---

## **Final Notes**
âœ… **Pros of this method**:
- **HAL remains unchanged** (SysTick still works at 1kHz).
- **Precise 44.1kHz timing** without affecting system functions.
- **Easy to adjust** if clock changes.

âš  **Cons**:
- Small **rounding errors** due to integer division (adjustable via prescaler tuning).
- **Busy-wait delays** consume CPU (use DMA/IRQ-based methods for audio streaming).

Would you like help optimizing this further (e.g., using DMA for audio buffering)? ðŸš€
